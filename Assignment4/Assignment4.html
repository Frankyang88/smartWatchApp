<!DOCTYPE html>
<html>
<link rel="stylesheet" type="text/css" href="COSC345.css">
<meta charset="UTF-8">
<title> COSC345 Assignment 4 </title>
<body>


<div>
    <h1>The experience of porting the Travel Application a new Emulator</h1>
    <p> Junyu Zhu, Alycia Ng, Ana Baltazar and Jialin Yang</p>
    </div>

    <div>
        <h1>Introduction</h1>
        <p> An emulator that provides the exact programming constructs, global variables and function calls that our Travel Application
        has made will translate into a 100% porting success. To expect an Emulator that mirrors the same Emulator environment that our Travel Application has been developed
        on, is unrealistic. Having a new Emulator that can provide a basic implementation of Google Maps API, a basic draw functionality using the Canvas API,
         mouse clicking events and text display support will result in minimal porting effort. Also, having an Emulator that does not have any third-party libraries,
            Javascript frameworks or Javascript conversion like TypeScript and Dart will make the porting process easier. In this task, we will be porting our Travel
            Application to a new Emulator. We will measure the ease of porting our Travel Application to the new Emulator by the complexity of the middleware and how the Travel Application
            behaves in the new Emulator environment.
        </p>
    </div>


    <div>
        <h1>Porting Schedule</h1>
        <h2>August 24</h2>
        <p><b>First Meeting</b></p>
        <p><b>Goal: To understand the given emulator</b></p>

        <p>Members will brainstorm and try to answer these questions.
        <ul>
            <li>What third-party libraries and JavaScript frameworks did the original authors use?</li>
            <li>What was the original development environment that the original authors used? For example, does their emulator work in all available web browsers?</li>
            <li>Or does it only work in specific browsers like Firefox?</li>
            <li>Does the Emulator have functions that we can use?</li>
            <li>What are the functions in the Emulator that we cannot use? </li>
            <li>What is the original application's behaviour on the given emulator? </li>
        </ul>

        If the original authors introduced themselves to us, then these questions would be answered faster. The time spent brainstorming and analysing the emulator would be lessened and the process
        of porting would be faster. If the original authors agree to demonstrate and show us how their developed application worked on their Emulator will massively reduce the time analysing the emulator.
        However the time spent on analysing the Emulator will take 3-4 hours if we cannot find the original authors.


        <h2>August 25</h2>
        <p><b>Second Meeting</b></p>
        <p><b>Goal: Write test cases for a draw and mouse event function</b></p>
        <p>In this meeting, the group will be split into pairs. Each pair will be given a specific task in the new emulator to write test cases for.
        They would need to understand each function's behaviour, how to call it and what it provides to the Application. To keep expectations realistic, each pair will be given a task that we expect a basic
            Emulator to provide. For example, we do not expect a very, basic SmartWatch Emulator to provide a Google Maps API service because not all development teams will develop a location-based application.
            At the very least, we expect a basic implementation of an Emulator to provide function calls that can display images and register user events.
        </p>
         <p> Our Travel Application heavily relies on being able to display shapes, text and images using the Canvas API.
             Therefore, Frank and Junyu will focus on finding functions in the emulator that will provide a basic draw function using the Canvas API for the Application.
        </p>

        <p> Our Travel Application expects user events like a swipe event and a button press. The Emulator that the Travel Application has been developed on would send a message on mouse events every time there is a mouseevent.
            The given emulator is expected to provide a callback to the Application.  </p>
        <p>Ana and Alycia are tasked with finding functions in the new Emulator that can provide functions that register mouse events and provide callbacks. To keep expectations realistic, we do
        not expect the given Emulator to record the previous and most recent mouse location to represent a swipe by the user. They would just need to analyse how to use a function in the new Emulator that can provide
            a way to register mouse events and communicate this to the application.
        </p>
        <p>Each pair will also write their section of the report and their findings. Ana will be tasked to proofread.</p>
        <p>
            After writing test cases, each pair should come up with an idea of how to use these functions (if found) and apply it to the middle layer. The middle layer connects the Application
            to the new Emulator by providing a thin wrapper. It can be as simple as renaming functions to match the one called by the application.
        </p>

        <p>
            Also it would be good if a member can find a use for every function in the new emulator that is not related to drawing a shape or registering a mouse event and apply it to the middle layer.
        </p>

        <p>We estimate the time taken to write test cases and incorporate it to the middle layer to be 3-4 hours for each pair.</p>

        <h2>August 26</h2>
        <p><b>Third Meeting</b></p>
        <p><b>Goal: Analysis of the Middlelayer</b></p>
        <p>At this point, the middle layer that has been developed should contain modified functions that were only present in the new Emulator. In this meeting, the group shall brainstorm together to answer these
        questions:
        <ul>
            <li>How well does the Travel Application port to the new Emulator using the middle layer?</li>
            <li>What is the overall performance of the Travel Application in responding to user events?</li>
            <li>How does the application behave?</li>
            <li>How far has the application progressed and developed using functions provided by the new Emulator? This question can be answered by how well the following questions are answered.</li>
            <ul>
                <li>Can the menu display work well on the application?</li>
                <li>Can the application respond correctly to user click events?</li>
                <li>Can the location details be displayed as expected?</li>
                <li>Can the images of the Travel Application be displayed correctly?</li>

            </ul>
            <li>Were there any functions in the new Emulator that was used by the Application that enhanced its purpose?</li>
        </ul>

        The group should then come up with a plan to incorporate functions from the old emulator to the middle layer to make up for missing functions that the application needs to work properly.

        <p>We estimate the time taken by this analysis to be 2-3 hours long. Implementing missing functions to the middle layer should be an additional 1-2 hours.</p>

        <h2>September 5</h2>
        <p><b>Fourth Meeting</b></p>
        <p><b>Goal: Testing Middle Layer</b></p>
        <p>In this meeting, we will test the middle layer and make sure that it is free of bugs. The functions present in the middle layer that were originally present in the old emulator will be
        a measure of how successful the porting is. In general, the more functions present in the middle layer that were originally present in the old emulator lessens the chance of achieving a successful
        port.
        </p>

        <p>This meeting can also be used to finish incorporating functions from the previous emulator if the members ran out of time in the previous meeting.</p>
        <p>We estimate the time taken for this meeting to be completed is 3-4 hours.</p>


    </div>

    <div>
        <h1>Analysis of Difficulties</h1>
        <h2>Ease of understanding the Emulator</h2>
        <p>The given Emulator did not use third-party Javascript libraries or frameworks. Therefore reading the functions in the Emulator were relatively intuitive
            and easy to understand. However, the implementation of registering click events to the application took some time to fully understand.
            We also found understanding how they implemented several draw functions using the Canvas API challenging.
        </p>

        <h2>Ease of using mouse services</h2>
        <p>We found early on in the porting process that the new Emulator did not provide a callback service for mouse events to the application. Also we found registering click events to be very limited.
        For example, the new Emulator only registered click events to show the application on click. This made developing the Middle Layer to provide user click events more complex and difficult.

        However we did expect not to find user swipe events.
            </p>
<p> To make up for the lack of user click event services and swipe event services, Frank and Junyu came up with drawing circles using the draw circle functions present in the new Emulator to draw four circles in each side of the frame. Mouse click events are registered on each
        circle to represent the original swipe functionality in our application. For example, swiping left originally meant that the user can access the previous page of the application. Swiping down meant that
        the user can access location details. In the process of porting the Travel Application, on click of the leftmost circle will allow the user to access the previous page of the application. Clicking of the rightmost
            circle allowed the user to access ? . Clicking the bottom-most circle allowed access to location details.
            Since the original emulator did not provide any callback functionality, Frank had write a time interval function in the middle layer that checks user click every 0.5 seconds.
        </p>

        <p>
            We found this process of porting to be very inefficient because it drastically reduced the Travel Application's ability to process user events and provide information to the user quickly. The lack
            of services offered by the Emulator meant that the Middle layer doubled its complexity and length.
        </p>

        <h2>Ease of drawing shapes</h2>
        <p>
            Unfortunately, the new Emulator can only provide functions and services that can draw and fill circles. The lack of drawing rectangles meant that we could not display the original menu layout which
            used rectangle menu buttons. The emulator cannot also provide positioning services to the application by accepting x and y coordinates from the Application. Therefore, we found displaying a menu to the user difficult.
        </p>

        <p>
            In the end, the middle layer (?) had to draw several, small circles positioned very close to each other and which lay in a horizontal line. This was our way of porting the menu layout to the new Emulator.
            We found this porting process to be tedious and inelegant. The menu display of the application does not look the way it was meant to be.
        </p>

        <h2>Displaying text</h2>
        <p>
            We found our problem of porting and displaying a menu layout were further compounded by the text display functions provided by the new Emulator. We found that the Emulator displayed text colour and shape colour to be
            exactly the same. We could not change the text colour to be different just by using the functions provided in the Emulator.  This meant that text could not be easily seen when the menu buttons are drawn behind it.
            Therefore we had to add more functions in the middle layer to allow for text to be seen in the menu layout.
        </p>

        <p>
            Overall, we found porting the menu layout to the new Emulator difficult, confusing and tedious.
        </p>

        <h2>Ease of displaying images</h2>
        <p>
            The new Emulator does not provide a way to display images on a Canvas. This meant that all the associated images in the Travel Application cannot be easily displayed using services provided by the Emulator.
            Since displaying images is an integral part of the Travel Application, we found that we cannot give up on this functionality. We extended our middle layer with functions that were originally present
            in the original emulator that the travel application was developed in. In this way, we can display the images from the application.
        </p>

        <h2>Porting Google Maps</h2>
        <p>
            As expected the emulator did not provide any DOM support and Google Maps API. Therefore, we have given up on porting and displaying Google Maps in our Travel Application after the user has made a decision
            on location. We found displaying Google Maps in the new Emulator without any DOM support and Google Maps API close to impossible unless we add in all the functions originally present in the original Emulator
            to the middle layer.

        </p>
        <p>
            However we found that we could not fully give up on using the Google Maps API. Calculating distances using the Google Maps API (specifically the distance geolocation matrix) is an integral part of the Travel
            Application's purpose. The Travel Application would need to provide locations to the user using the specified distances. Therefore we added to the middle layer, the distance matrix calculations to be used
            by the Travel Application. Since this just meant copying and pasting the original functions to the middle layer which we found easy and straightforward.
        </p>
                <img src='images/circle.png'>




    </div>

    <div>
        <h1>Critique of documentation of the given Emulator</h1>
            <p>
                The given emulator has few comments and documentations, which are limited our ability to port. Lots of efforts were spent
                on testing their codes and checking its behavior. For example, we expected the drawLine method to draw a line without any hassles.
                After several tests, we found that this method erased the previous line and would redraw a new line. Having good documentation would have saved us a lot of time analysing the behaviour of the
                the drawLine method.
                </p>


        <p>
            We were also unable to find the original authors of the Emulator. This meant that we had to rely on the minimal comments left on the Emulator to assess each methods use and behaviour.
            We found that the comments left on the Emulator were too minimal and were not informative. For example, the comment left on the Emulator object "Emulator object. Library style functions." were not useful
            because it had several functions in the Emulator object that were not commented and explained.
        </p>

        <p>
            Overall, we did not find the lack of documentation to heavily affect our ability to port our Application to the Emulator. It would have been nice however if the original authors provided documentation
            oh what each method could provide to the application.
        </p>

    </div>


    <div>
        <h1>Critiques of emulator structure and code quality</h1>
        <p>
            We found the emulator that we were given to be very disappointing. We found that the emulator being able to
            draw circular shapes to be very limiting. It also meant that their emulator cannot generalize well to provide draw services
            to other applications needing to display other shapes other than a circle. We thought that an Emulator being able to provide draw services to an application a basic
            feature. Therefore, the fact that this emulator did not provide a general draw service meant that the effort and time spent porting our Application to the Emulator
            difficult and long.

            However other draw functions present in the emulator made the porting process a little easier. 
            For example, the fillArc, setupText, fillText, translate functions present were used to draw and display objects, text and shapes but not images. We also used their getPosition function worked well and which we used in the final process of porting.
        </p>

        <p> The way the Emulator registers user clicks and events were too specific to their
            application's needs. For example, there was a method named toggleClock,which displays a clock on mouse click. We could not find a way to use these mouse event functions in the emulator to work with our application.
            The fact that the emulator could not provide a general way to provide a mouse event callback or register user events to be extremely disappointing.
            Also the way the emulator structure was set up did not allow for any user interaction to occur. We expect a proper emulator that can wrap a function from the application and call it when certain trigger is activated at the very minimum.
            For example, it does not provide a wrapping function for call-back, therefore we have to check the mouse event periodically with "setInterval" function from JavaScript.
        </p>

        <p>
            In general, the fact that the given Emulator could not provide these two basic services to our Application made the process of porting difficult and complex. To us, a good Emulator would have at least provided
            us these two services with some documentation and commenting.
        </p>

        <p>
            There weren't any functions in the Emulator that made us "wow". We honestly thought that this group did not put a lot of effort in developing an Emulator and an Application.
    </p>

        </p>
      
            <h4>Codes Analysis</h4>
            <ul>
                <li>getImageData:This method returns data of the image and can put it onto a data structure like an array.But, the emulator does not provide a way to draw images. </li>

                <li>getPosition : get the coordinate of a mouse click with mousedown event. This is not a good solution to mouse events as the app has to check the mouse position from time to time. The better solution is to provide a callback in the emulator</li>

                <li>showClock: perhaps show clock</li>

                <li>StartEmulator: On setup, the emulator adds a mousedown click event listener to the canvas and a clock (which we’re assuming is the original author’s app).Translate the current origin to (160,160)</li>

                <li>getRadius: return nearly half of the canvas height</li>

                <li>AppendText: modify a html element that holds some texts. This offers a very limited interface to display texts.</li>

                <li>setupText:  set up texts format on canvas</li>

                <li>toggleClock: exchange visibility between eventText and canvas</li>

                <li>fillArc: draw a curve or circle  and fill color, this is the most useful method when we work on porting.</li>

                <li>fillSect: draw a curve or circle. This is similiar to fillArc. We are not sure the purpose</li>

                <li>createGradient:create a radial/circular gradient</li>

                <li> drawGradient:   format the color of gradient </li>

                <li> Rotate: rotate an angle</li>

                <li>Translate:translate the current origin to a new position</li>

                <li> FillText: draw text at position(x,y)</li>

                <li>drawLine: draw line from (0,0) to (0,-length) with defined width. This method will erase previous lines and draw a new one</li>


          
        </ul>
    </div>
    <div id = "Conclusion">
        <h3>Conclusion</h3>
        <ul>
            <p>Here is our <a href="index.html" >TravelApp</a>. </p>
            <p>We build a middle layer that wrap the methods in the given emulator and extend some necessary functionalities. And some functionalities are cut to save time. This new application performs poorly when the buttons are clicked. Our porting is roughly successful as we could create buttons and react to a click event. However, the performance is worse than the original app.

            </p>


        </ul>
    </div>
</section>
</body>
</html>
